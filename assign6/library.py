# -*- coding: utf-8 -*-
"""library.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e5qvNrsVqywjTDLd8CjWA5udRXzDCiOK
"""

import math
import numpy as np
import matplotlib.pyplot as plt

# Runge-Kutta

def runge_kutta(x0, v0, t, dxdt, dvdt, dt, tn):
    import matplotlib.pyplot as plt
    X = []
    V = []
    T = []
    while t < tn:
        T.append(t)
        k1x = dt*dxdt(x0, v0, t)
        k1v = dt*dvdt(x0,v0,t)
        
        k2x = dt*dxdt(x0+(k1x/2), v0+(k1v/2), t+(dt/2))
        k2v = dt*dvdt(x0+(k1x/2), v0+(k1v/2), t+(dt/2))
        
        k3x = dt*dxdt(x0+(k2x/2), v0+(k2v/2), t+(dt/2))
        k3v = dt*dvdt(x0+(k2x/2), v0+(k2v/2), t+(dt/2))        
        
        k4x = dt*dxdt(x0+(k3x/2), v0+(k3v/2), t+(dt/2))
        k4v = dt*dvdt(x0+(k3x/2), v0+(k3v/2), t+(dt/2))        
        
        x0 += (k1x + 2*k2x + 2*k3x + k4x)/6
        v0 += (k1v + 2*k2v + 2*k3v + k4v)/6
        t += dt
        X.append(x0)
        V.append(v0)
        plt.plot(T, X, color="blue")
        plt.plot(T, V, color="red")
        
# Shooting Method

def runge_kutta_for_shooting(d2ydx2, dydx, x0, y0, z0, xf, h):
    x = [x0]
    y = [y0]
    z = [z0]
    N = int((xf-x0)/h)
    for i in range(N):        
        k1 = h * dydx(x[i], y[i], z[i])
        l1 = h * d2ydx2(x[i], y[i], z[i])
        
        k2 = h * dydx(x[i] + h/2, y[i] + k1/2, z[i] + l1/2)
        l2 = h * d2ydx2(x[i] + h/2, y[i] + k1/2, z[i] + l1/2)
        
        k3 = h * dydx(x[i] + h/2, y[i] + k2/2, z[i] + l2/2)
        l3 = h * d2ydx2(x[i] + h/2, y[i] + k2/2, z[i] + l2/2)
        
        k4 = h * dydx(x[i] + h, y[i] + k3, z[i] + l3)
        l4 = h * d2ydx2(x[i] + h, y[i] + k3, z[i] + l3)
        
        x.append(x[i] + h)
        y.append(y[i] + (k1 + 2*k2 + 2*k3 + k4)/6)
        z.append(z[i] + (l1 + 2*l2 + 2*l3 + l4)/6)
    return x, y, z

def lag_interpol(zeta_h, zeta_l, yh, yl, y):
    zeta = zeta_l + (zeta_h - zeta_l) * (y - yl)/(yh - yl)
    return zeta

def shooting_method(d2ydx2, dydx, x0, y0, xf, yf, z1, z2, h, tol=1e-6):
    x, y, z = runge_kutta_for_shooting(d2ydx2, dydx, x0, y0, z1, xf, h)
    yn = y[-1]
    if abs(yn - yf) > tol:
        if yn < yf:
            zeta_l = z1
            yl = yn
            x, y, z = runge_kutta_for_shooting(d2ydx2, dydx, x0, y0, z2, xf, h)
            yn = y[-1]
            if yn > yf:
                zeta_h = z2
                yh = yn
                zeta = lag_interpol(zeta_h, zeta_l, yh, yl, yf)
                x, y, z = runge_kutta_for_shooting(d2ydx2, dydx, x0, y0, zeta, xf, h)
                return x, y
            else:
                print("Try another set of guesses for bracketing.")
        elif yn > yf:
            zeta_h = z1
            yh = yn
            x, y, z = runge_kutta_for_shooting(d2ydx2, dydx, x0, y0, z2, xf, h)
            yn = y[-1]
            if yn < yf:
                zeta_l = z2
                yl = yn
                zeta = lag_interpol(zeta_h, zeta_l, yh, yl, yf)
                x, y, z = runge_kutta_for_shooting(d2ydx2, dydx, x0, y0, zeta, xf, h)
                return x, y
            else:
                print("Try another set of guesses for bracketing.")
    else:
        return x, y

# Heat Equation solver using PDE

def heat_eqn(temp, Lx, Nx, Lt, Nt):
    import matplotlib.pyplot as plt
    hx = Lx/Nx
    ht = Lt/Nt
    alpha = ht/(hx**2)
    V0 = [0 for i in range(Nx+1)]
    V1 = [0 for i in range(Nx+1)]
    i_list = []
    if alpha < 0.5:
        for i in range(Nx+1):
            V0[i] = (temp(Nx, i))
            i_list.append(i*hx)
    for j in range(0, 1000):
        for i in range(1, Nx):
            if i == 0:
                V1[i] = (1 - 2*alpha)*V0[i] + alpha*V0[i+1]
            elif i == Nx:
                V1[i] = alpha*V0[i-1] + (1 - 2*alpha)*V0[i]
            else:
                V1[i] = alpha*V0[i-1] + (1 - 2*alpha)*V0[i] + alpha*V0[i+1]
        for i in range(1, Nx):
            V0[i] = V1[i]
        if j == 0  or j == 5 or j == 10 or j == 50 or j == 100 or j == 500 or j == 1000:
            plt.plot(i_list, V0)
            plt.xlabel("Position (x)")
            plt.ylabel("Temperature (T)")
    plt.show()

# Eigenvalue & Eigenvector

def eigen(A,x0,xk):
    k = 500
    y = np.matrix(x0)
    for i in range(0,k):
        sum = 0
        for j in range(0,3):
            sum += y[0,j]*x0[0,j]
        xky = (sum)
        for l in range(0,3):
            sum = 0
            for j in range(0,3):
                sum += A[l,j]*x0[0,j]
            xk[0,l] = (sum)
        x0 = np.matrix(xk)
        sum = 0
        for j in range(0,3):
            sum += y[0,j]*xk[0,j]
        xk1y = (sum)
        if i == 0:
            l0 = (sum)
        if i>0:
            if xky == 0:
                break
            lk = xk1y/xky
            if abs(lk-l0)<10**-3:
                break
            l0 = lk
    return lk,xk