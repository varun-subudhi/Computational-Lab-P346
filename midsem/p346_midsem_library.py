# -*- coding: utf-8 -*-
"""p346_midsem_library.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15qdV9CDfSBuLuiCykqX6RlOBY6NUH7IM
"""

# pRNG LCG
a = 1103515245
c = 12345
m = 32768.
def myrand(x):  
	return ((a * x + c) % m) / m

# Read matrix from a file given as a string
def read_matrix(file):
    with open(file, 'r') as f:
        a = [[int(num) for num in line.split(' ')] for line in f]
    return a

# Derivation function at x = x0 with default tolerance (h-value) = 1e-6
def derivative(f, x0, tol=1e-6):
    df = (f(x0+tol) - f(x0-tol))/(2*tol)
    return df

# Newton-Raphson method of finding roots
def newton_raphson(f, x0, tol):
    iterations = []
    abs_error = []
    max_iter = 400
    for i in range(max_iter):
        x_prev = x0
        x0 = x0 - (f(x0)/derivative(f, x0))
        iterations.append(i)
        abs_error.append(abs(x0 - x_prev))

        if abs(x0 - x_prev)<tol:
            return x0

# Gauss-Seidel Algorithm
def gauss_seidel(a, x ,b):     
    n = len(a)                   
    for i in range(0, n):        
        d = b[i]                  
        for j in range(0, n):     
            if(i != j):
                d-=a[i][j] * x[j]      
        x[i] = d / a[i][i]          
    return x

# Partial pivoting with matrix 'a', vector 'b', and dimension 'n'
def partial_pivot(a,b,n):
    count = 0   # keeps a track of number of exchanges (odd number of exchanges adds a phase of -1 to determinant)
    for i in range(n-1):
        if abs(a[i][i]) == 0:
            for j in range(i+1,n):
                if abs(a[j][i]) > abs(a[i][i]):
                    a[j], a[i] = a[i], a[j]  # interchange ith and jth rows of matrix 'a'
                    count += 1
                    b[j], b[i] = b[i], b[j]  # interchange ith and jth elements of vector 'b'
    return a, b, count

# Gauss-Jordan algorithm
def gauss_jordan(a,b):
    partial_pivot(a,b,n)
    for i in range(n):
        pivot = a[i][i]
        b[i] = b[i]/pivot
        for c in range(i, n):
            a[i][c] = a[i][c]/pivot

        for k in range(n):
            if k != i and a[k][i] != 0:
                factor = a[k][i]
                b[k] = b[k] - factor*b[i]
                for j in range(i, n):
                    a[k][j] = a[k][j] - factor*a[i][j]

def square_fit(x,y):
  X=[[0 for i in range(n)] for j in range(n)]
  xsum = 0
  for i in range(n):
   for j in range(n):
      xsum = xsum + x[j]**(i+j)
   X[i] = xsum
   xsum = 0

  Y=[0 for i in range(n)]
  ysum = 0
  for i in range (n):
   for j in range (n):
      ysum = ysum + y[j]*(x[j]**(i-1))
   Y[i] = ysum
   ysum = 0

  gauss_jordan(x,y)
  print(y)