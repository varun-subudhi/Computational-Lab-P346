# -*- coding: utf-8 -*-
"""library.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Qa4mMjzWBqNQu0NBw0ozM3aKBHhfCP_
"""

# lu decomposition method to solve linear equations

def lu_decomp(A,b,n):
    L = [[0 for x in range(n)] for y in range(n)]
    U = [[0 for x in range(n)] for y in range(n)]

    for j in range(0,n):
        for i in range(0,n):
            sum = 0
            for k in range(0,i):
                sum += L[i][k] * U[k][j]
            U[i][j] = A[i][j] - sum
        for i in range(0,n):
            sum = 0
            for k in range(0,j):
                sum += L[i][k] * U[k][j]
            L[i][j] = (1 / U[j][j]) * (A[i][j] - sum)
    for i in range(0,n):
        sum = 0
        for j in range(0,i):
            sum += L[i][j] * b[j]
        b[i] = b[i] - sum
    for i in range(n-1,-1,-1):
        sum = 0
        for j in range(i+1,n):
            sum += U[i][j] * b[j]
        b[i] = round((b[i] - sum) / U[i][i],3)
    print(b)

def transpose(L,n):
    U = [[L[j][i] for j in range(len(L))] for i in range(len(L[0]))]
    return U

# random number generator which stores output in array

def rand_lcg(r0: float, n: int):
  a = 1103515245
  c = 12345
  m = 32768
  l = []

  for i in range (0, n):
    r0 = float(((a*r0 + c) % m)/m)
    l.append(r0)
  return l

# derivative

def derivative(f, x0, tol=1e-6):
    df = (f(x0+tol) - f(x0-tol))/(2*tol)
    return df

# double derivative

def double_derivative(f, x0, tol=1e-6):
    f1 = derivative(f, x0) + tol
    f0 = derivative(f, x0) - tol
    ddf = (f1-f0)/(2*tol)
    return ddf

# newton-Raphson method of finding roots

def newton_raphson(f, x0, tol):
    iterations = []
    abs_error = []
    max_iter = 200
    for i in range(max_iter):
        x_prev = x0
        x0 = x0 - (f(x0)/derivative(f, x0))
        iterations.append(i)
        abs_error.append(abs(x0 - x_prev))

        if abs(x0 - x_prev)<tol:
            return x0, abs_error, iterations

# simpson integration scheme

def simpson(f, a, b, n):
    if n%2 == 1:
        n = n+1
    x = a
    sum = f(a)
    h = (b-a)/n
    for i in range(1, n):
        if i%2 == 0:
            w = 2
        elif i%2 == 1:
            w = 4
        elif i == n:
            w = 1
        sum += w*f(x)
        x += h
    return (h/3)*sum

# RK4 method

def runge_kutta(x, v, t, dxdt, dvdt, tn):
    dt = 0.01
    X = []
    V = []
    T = []
    while t < tn:
        k1x = dt*dxdt(x,v,t)
        k1v = dt*dvdt(x,v,t)

        k2x = dt*dxdt(x+k1x/2,(v+k1v/2),(t+dt/2))
        k2v = dt*dvdt((x+k1x/2),v+k1v/2,(t+dt/2))

        k3x = dt*dxdt(x+k2x/2,(v+k2v/2),(t+dt/2))
        k3v = dt*dvdt((x+k2x/2),v+k2v/2,(t+dt/2))

        k4x = dt*dxdt(x+k3x,(v+k3v),(t+dt))
        k4v = dt*dvdt((x+k3x),v+k3v,(t+dt))

        kx = (k1x+2*k2x+2*k3x+k4x)/6
        kv = (k1v+2*k2v+2*k3v+k4v)/6
        x = x + kx
        X.append(x)
        v = v + kv
        V.append(v)
        t += dt
        T.append(t)
    plt.plot(X,V)
    plt.xlabel("Height (h)")
    plt.ylabel("Velocity (v)")

def eigen(A,x0,xk):
    k = 500
    y = np.matrix(x0)
    for i in range(0,k):
        sum = 0
        for j in range(0,3):
            sum += y[0,j] * x0[0,j]
        xky = (sum)
        for l in range(0,3):
            sum = 0
            for j in range(0,3):
                sum += A[l,j] * x0[0,j]
            xk[0,l] = (sum)
        x0 = np.matrix(xk)
        sum = 0
        for j in range(0,3):
            sum += y[0,j] * xk[0,j]
        xk1y = (sum)
        if i == 0:
            l0 = (sum)
        if i>0:
            if xky == 0:
                break
            lk = xk1y/xky
            if abs(lk - l0) < (10**-3):
                break
            l0 = lk
    return lk,xk

def give_X(B):
    X = [[B[i][len(B)] for j in range(1)] for i in range(len(B))]
    return X

def gj_elim(M):
    for i in range(len(M)):
        if M[i][i] == 0:
            for j in range(i+1, len(M)):
               if M[j][i]**2 > M[i][i]**2:
                  M[j], M[i] = M[i], M[j]
        M[i] = [x/M[i][i] for x in M[i]]
        for j in range(i+1, len(M)):
            c_down = (M[j][i])/(M[i][i])
            for p in range(len(M[0])):
                M[j][p] = M[j][p] - c_down*M[i][p]
    for i in range(len(M)-1, 0, -1):
        for j in range(i):
            for q in range(len(M[0])-1, 0, -1):
                M[j][q] = M[j][q] - M[j][i]*M[i][q]
    return M
    
def polyfit(x, y, o): # o is the max order of polynomial
    N = []
    for i in range(o):
        r = []
        for j in range(o):
            sum2 = 0
            for k in range(len(x)):
                sum2 += (x[k][0]**(i+j))
            r.append(sum2)
        sum1 = 0
        for l in range(len(y)):
            sum1 += ((x[l][0]**i)*y[l][0])
        r.append(sum1)
        N.append(r)
    X = give_X(gj_elim(N))
    return X